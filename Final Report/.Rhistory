gfp1_dat
gfp1_dat[[1]]
na.omit(gfp1_dat[[1]])
# Write a function that, given a sensor and two sets of lambda bands, returns a list of properties
# Sensor data format:
initSensor <- function(sensor_data, lambda_1, lambda_2, e0) {
# Clean data
ox_lambda <- na.omit(sensor_data[[1]])
print(ox_lambda)
ox_value <- na.omit(sensor_data[[2]])
red_lambda <- na.omit(sensor_data[[3]])
red_value <- na.omit(sensor_data[[4]])
# Set delta
delta <- mean(ox_value[ox_lambda >= lambda_2[0] & ox_lambda <= lambda_2[1]]) /
mean(red_value[red_lambda >= lambda_2[0] & red_lambda <= lambda_2[1]])
print(paste("Delta is: ", delta))
# Set Rmin and Rmax
Rmin <- mean(red_value[red_lambda >= lambda_1[0] & red_lambda <= lambda_1[1]]) /
mean(red_value[red_lambda >= lambda_2[0] & red_lambda <= lambda_2[1]])
Rmax <- mean(ox_value[ox_lambda >= lambda_1[0] & ox_lambda <= lambda_1[1]]) /
mean(ox_value[ox_lambda >= lambda_2[0] & ox_lambda <= lambda_2[1]])
# Generate some R, OxD, and E values
R <- seq(Rmin, Rmax, by = 0.001)
OxD_values <- OXD(R, Rmin, Rmax, delta)
E_values <- E(e0, R, Rmin, Rmax, delta)
# Return the final list
return(list(delta = delta, Rmin = Rmin, Rmax = Rmax, R = R, OxD = OxD_values, E = E_values))
}
# Import GFP1/2 data
gfp1_dat <- read.csv("rogfp1.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
gfp2_dat <- read.csv("rogfp2.csv", header = FALSE, stringsAsFactors=FALSE,
fileEncoding="UTF-8-BOM")
# Set known midpoint potentials
gfp1_e0 <-  -288
gfp2_e0 <- -272
# Get other properties
gfp1_prop <- initSensor(gfp1_dat, c(390, 410), c(470, 480), gfp1_e0)
gfp2_prop <- initSensor(gfp2_dat, c(390, 410), c(490, 500), gfp2_e0)
# Write a function that, given a sensor and two sets of lambda bands, returns a list of properties
# Sensor data format:
initSensor <- function(sensor_data, lambda_1, lambda_2, e0) {
# Clean data
ox_lambda <- na.omit(sensor_data[[1]])
ox_value <- na.omit(sensor_data[[2]])
red_lambda <- na.omit(sensor_data[[3]])
red_value <- na.omit(sensor_data[[4]])
# Set delta
delta <- mean(ox_value[ox_lambda >= lambda_2[0] & ox_lambda <= lambda_2[1]]) /
mean(red_value[red_lambda >= lambda_2[0] & red_lambda <= lambda_2[1]])
print(paste("Delta is: ", delta))
# Set Rmin and Rmax
Rmin <- mean(red_value[red_lambda >= lambda_1[0] & red_lambda <= lambda_1[1]]) /
mean(red_value[red_lambda >= lambda_2[0] & red_lambda <= lambda_2[1]])
Rmax <- mean(ox_value[ox_lambda >= lambda_1[0] & ox_lambda <= lambda_1[1]]) /
mean(ox_value[ox_lambda >= lambda_2[0] & ox_lambda <= lambda_2[1]])
# Generate some R, OxD, and E values
R <- seq(Rmin, Rmax, by = 0.001)
OxD_values <- OXD(R, Rmin, Rmax, delta)
E_values <- E(e0, R, Rmin, Rmax, delta)
# Return the final list
return(list(delta = delta, Rmin = Rmin, Rmax = Rmax, R = R, OxD = OxD_values, E = E_values))
}
# Import GFP1/2 data
gfp1_dat <- read.csv("rogfp1.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
gfp2_dat <- read.csv("rogfp2.csv", header = FALSE, stringsAsFactors=FALSE,
fileEncoding="UTF-8-BOM")
# Set known midpoint potentials
gfp1_e0 <-  -288
gfp2_e0 <- -272
# Get other properties
gfp1_prop <- initSensor(gfp1_dat, c(390, 410), c(470, 480), gfp1_e0)
gfp2_prop <- initSensor(gfp2_dat, c(390, 410), c(490, 500), gfp2_e0)
# Write a function that, given a sensor and two sets of lambda bands, returns a list of properties
# Sensor data format:
initSensor <- function(sensor_data, lambda_1, lambda_2, e0) {
# Clean data
ox_lambda <- na.omit(sensor_data[[1]])
ox_value <- na.omit(sensor_data[[2]])
red_lambda <- na.omit(sensor_data[[3]])
red_value <- na.omit(sensor_data[[4]])
# Set delta
delta <- mean(ox_value[ox_lambda >= lambda_2[0] & ox_lambda <= lambda_2[1]]) /
mean(red_value[red_lambda >= lambda_2[0] & red_lambda <= lambda_2[1]])
print(paste("ox_value is: ", ox_value[ox_lambda >= lambda_2[0] & ox_lambda <= lambda_2[1]]))
print(paste("Delta is: ", delta))
# Set Rmin and Rmax
Rmin <- mean(red_value[red_lambda >= lambda_1[0] & red_lambda <= lambda_1[1]]) /
mean(red_value[red_lambda >= lambda_2[0] & red_lambda <= lambda_2[1]])
Rmax <- mean(ox_value[ox_lambda >= lambda_1[0] & ox_lambda <= lambda_1[1]]) /
mean(ox_value[ox_lambda >= lambda_2[0] & ox_lambda <= lambda_2[1]])
# Generate some R, OxD, and E values
R <- seq(Rmin, Rmax, by = 0.001)
OxD_values <- OXD(R, Rmin, Rmax, delta)
E_values <- E(e0, R, Rmin, Rmax, delta)
# Return the final list
return(list(delta = delta, Rmin = Rmin, Rmax = Rmax, R = R, OxD = OxD_values, E = E_values))
}
# Import GFP1/2 data
gfp1_dat <- read.csv("rogfp1.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
gfp2_dat <- read.csv("rogfp2.csv", header = FALSE, stringsAsFactors=FALSE,
fileEncoding="UTF-8-BOM")
# Set known midpoint potentials
gfp1_e0 <-  -288
gfp2_e0 <- -272
# Get other properties
gfp1_prop <- initSensor(gfp1_dat, c(390, 410), c(470, 480), gfp1_e0)
gfp2_prop <- initSensor(gfp2_dat, c(390, 410), c(490, 500), gfp2_e0)
# Write a function that, given a sensor and two sets of lambda bands, returns a list of properties
# Sensor data format:
initSensor <- function(sensor_data, lambda_1, lambda_2, e0) {
# Clean data
ox_lambda <- na.omit(sensor_data[[1]])
ox_value <- na.omit(sensor_data[[2]])
red_lambda <- na.omit(sensor_data[[3]])
red_value <- na.omit(sensor_data[[4]])
# Set delta
delta <- mean(ox_value[ox_lambda >= lambda_2[0] & ox_lambda <= lambda_2[1]]) /
mean(red_value[red_lambda >= lambda_2[0] & red_lambda <= lambda_2[1]])
print(paste("Lambda 2:: ", lambda_2[0], " ", lambda_2[1]))
print(paste("ox_value is: ", ox_value[ox_lambda >= lambda_2[0] & ox_lambda <= lambda_2[1]]))
print(paste("Delta is: ", delta))
# Set Rmin and Rmax
Rmin <- mean(red_value[red_lambda >= lambda_1[0] & red_lambda <= lambda_1[1]]) /
mean(red_value[red_lambda >= lambda_2[0] & red_lambda <= lambda_2[1]])
Rmax <- mean(ox_value[ox_lambda >= lambda_1[0] & ox_lambda <= lambda_1[1]]) /
mean(ox_value[ox_lambda >= lambda_2[0] & ox_lambda <= lambda_2[1]])
# Generate some R, OxD, and E values
R <- seq(Rmin, Rmax, by = 0.001)
OxD_values <- OXD(R, Rmin, Rmax, delta)
E_values <- E(e0, R, Rmin, Rmax, delta)
# Return the final list
return(list(delta = delta, Rmin = Rmin, Rmax = Rmax, R = R, OxD = OxD_values, E = E_values))
}
# Import GFP1/2 data
gfp1_dat <- read.csv("rogfp1.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
gfp2_dat <- read.csv("rogfp2.csv", header = FALSE, stringsAsFactors=FALSE,
fileEncoding="UTF-8-BOM")
# Set known midpoint potentials
gfp1_e0 <-  -288
gfp2_e0 <- -272
# Get other properties
gfp1_prop <- initSensor(gfp1_dat, c(390, 410), c(470, 480), gfp1_e0)
gfp2_prop <- initSensor(gfp2_dat, c(390, 410), c(490, 500), gfp2_e0)
# Write a function that, given a sensor and two sets of lambda bands, returns a list of properties
# Sensor data format:
initSensor <- function(sensor_data, lambda_1, lambda_2, e0) {
# Clean data
ox_lambda <- na.omit(sensor_data[[1]])
ox_value <- na.omit(sensor_data[[2]])
red_lambda <- na.omit(sensor_data[[3]])
red_value <- na.omit(sensor_data[[4]])
# Set delta
delta <- mean(ox_value[ox_lambda >= lambda_2[1] & ox_lambda <= lambda_2[2]]) /
mean(red_value[red_lambda >= lambda_2[1] & red_lambda <= lambda_2[2]])
print(paste("Lambda 2:: ", lambda_2[1], " ", lambda_2[2]))
print(paste("Delta is: ", delta))
# Set Rmin and Rmax
Rmin <- mean(red_value[red_lambda >= lambda_1[1] & red_lambda <= lambda_1[2]]) /
mean(red_value[red_lambda >= lambda_2[1] & red_lambda <= lambda_2[2]])
Rmax <- mean(ox_value[ox_lambda >= lambda_1[1] & ox_lambda <= lambda_1[2]]) /
mean(ox_value[ox_lambda >= lambda_2[1] & ox_lambda <= lambda_2[2]])
# Generate some R, OxD, and E values
R <- seq(Rmin, Rmax, by = 0.001)
OxD_values <- OXD(R, Rmin, Rmax, delta)
E_values <- E(e0, R, Rmin, Rmax, delta)
# Return the final list
return(list(delta = delta, Rmin = Rmin, Rmax = Rmax, R = R, OxD = OxD_values, E = E_values))
}
# Import GFP1/2 data
gfp1_dat <- read.csv("rogfp1.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
gfp2_dat <- read.csv("rogfp2.csv", header = FALSE, stringsAsFactors=FALSE,
fileEncoding="UTF-8-BOM")
# Set known midpoint potentials
gfp1_e0 <-  -288
gfp2_e0 <- -272
# Get other properties
gfp1_prop <- initSensor(gfp1_dat, c(390, 410), c(470, 480), gfp1_e0)
gfp2_prop <- initSensor(gfp2_dat, c(390, 410), c(490, 500), gfp2_e0)
# Define the fraction oxidized
OXD <- function(R, Rmin, Rmax, delta) {
return (
(R - Rmin)/((R - Rmin) + (delta*(Rmax - R)))
)
}
# Define the redox potential
E <- function(e0, R, Rmin, Rmax, delta) {
return(e0 - 12.71 * log((delta*Rmax - delta*R)/(R-Rmin)))
}
# Write a function that, given a sensor and two sets of lambda bands, returns a list of properties
# Sensor data format:
initSensor <- function(sensor_data, lambda_1, lambda_2, e0) {
# Clean data
ox_lambda <- na.omit(sensor_data[[1]])
ox_value <- na.omit(sensor_data[[2]])
red_lambda <- na.omit(sensor_data[[3]])
red_value <- na.omit(sensor_data[[4]])
# Set delta
delta <- mean(ox_value[ox_lambda >= lambda_2[1] & ox_lambda <= lambda_2[2]]) /
mean(red_value[red_lambda >= lambda_2[1] & red_lambda <= lambda_2[2]])
print(paste("Lambda 2:: ", lambda_2[1], " ", lambda_2[2]))
print(paste("Delta is: ", delta))
# Set Rmin and Rmax
Rmin <- mean(red_value[red_lambda >= lambda_1[1] & red_lambda <= lambda_1[2]]) /
mean(red_value[red_lambda >= lambda_2[1] & red_lambda <= lambda_2[2]])
Rmax <- mean(ox_value[ox_lambda >= lambda_1[1] & ox_lambda <= lambda_1[2]]) /
mean(ox_value[ox_lambda >= lambda_2[1] & ox_lambda <= lambda_2[2]])
# Generate some R, OxD, and E values
R <- seq(Rmin, Rmax, by = 0.001)
OxD_values <- OXD(R, Rmin, Rmax, delta)
E_values <- E(e0, R, Rmin, Rmax, delta)
# Return the final list
return(list(delta = delta, Rmin = Rmin, Rmax = Rmax, R = R, OxD = OxD_values, E = E_values))
}
# Import GFP1/2 data
gfp1_dat <- read.csv("rogfp1.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
gfp2_dat <- read.csv("rogfp2.csv", header = FALSE, stringsAsFactors=FALSE,
fileEncoding="UTF-8-BOM")
# Set known midpoint potentials
gfp1_e0 <-  -288
gfp2_e0 <- -272
# Get other properties
gfp1_prop <- initSensor(gfp1_dat, c(390, 410), c(470, 480), gfp1_e0)
gfp2_prop <- initSensor(gfp2_dat, c(390, 410), c(490, 500), gfp2_e0)
# Write a function that, given a sensor and two sets of lambda bands, returns a list of properties
# Sensor data format:
initSensor <- function(sensor_data, lambda_1, lambda_2, e0) {
# Clean data
ox_lambda <- na.omit(sensor_data[[1]])
ox_value <- na.omit(sensor_data[[2]])
red_lambda <- na.omit(sensor_data[[3]])
red_value <- na.omit(sensor_data[[4]])
# Set delta
delta <- mean(ox_value[ox_lambda >= lambda_2[1] & ox_lambda <= lambda_2[2]]) /
mean(red_value[red_lambda >= lambda_2[1] & red_lambda <= lambda_2[2]])
# Set Rmin and Rmax
Rmin <- mean(red_value[red_lambda >= lambda_1[1] & red_lambda <= lambda_1[2]]) /
mean(red_value[red_lambda >= lambda_2[1] & red_lambda <= lambda_2[2]])
Rmax <- mean(ox_value[ox_lambda >= lambda_1[1] & ox_lambda <= lambda_1[2]]) /
mean(ox_value[ox_lambda >= lambda_2[1] & ox_lambda <= lambda_2[2]])
# Generate some R, OxD, and E values
R <- seq(Rmin, Rmax, by = 0.001)
OxD_values <- OXD(R, Rmin, Rmax, delta)
E_values <- E(e0, R, Rmin, Rmax, delta)
# Return the final list
return(list(delta = delta, Rmin = Rmin, Rmax = Rmax, R = R, OxD = OxD_values, E = E_values))
}
# Import GFP1/2 data
gfp1_dat <- read.csv("rogfp1.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
gfp2_dat <- read.csv("rogfp2.csv", header = FALSE, stringsAsFactors=FALSE,
fileEncoding="UTF-8-BOM")
# Set known midpoint potentials
gfp1_e0 <-  -288
gfp2_e0 <- -272
# Get other properties
gfp1_prop <- initSensor(gfp1_dat, c(390, 410), c(470, 480), gfp1_e0)
gfp2_prop <- initSensor(gfp2_dat, c(390, 410), c(490, 500), gfp2_e0)
gfp1_prop
option('max.print') = 5
options(max.print = 5)
gfp1_prop
matrix(c(1,2,3,4), c(5,4,23,2))
matrix(x = c(1,2,3,4), y = c(5,4,23,2))
data.table(lambda = c(1,2,3,4), value = c(5,4,23,2))
data.frame(lambda = c(1,2,3,4), value = c(5,4,23,2))
# Write a function that, given a sensor and two sets of lambda bands, returns a list of properties
# Sensor data format:
initSensor <- function(sensor_data, lambda_1, lambda_2, e0) {
# Clean data
ox_lambda <- na.omit(sensor_data[[1]])
ox_value <- na.omit(sensor_data[[2]])
red_lambda <- na.omit(sensor_data[[3]])
red_value <- na.omit(sensor_data[[4]])
# Set delta
delta <- mean(ox_value[ox_lambda >= lambda_2[1] & ox_lambda <= lambda_2[2]]) /
mean(red_value[red_lambda >= lambda_2[1] & red_lambda <= lambda_2[2]])
# Set Rmin and Rmax
Rmin <- mean(red_value[red_lambda >= lambda_1[1] & red_lambda <= lambda_1[2]]) /
mean(red_value[red_lambda >= lambda_2[1] & red_lambda <= lambda_2[2]])
Rmax <- mean(ox_value[ox_lambda >= lambda_1[1] & ox_lambda <= lambda_1[2]]) /
mean(ox_value[ox_lambda >= lambda_2[1] & ox_lambda <= lambda_2[2]])
# Generate some R, OxD, and E values
R <- seq(Rmin, Rmax, by = 0.001)
OxD_values <- OXD(R, Rmin, Rmax, delta)
E_values <- E(e0, R, Rmin, Rmax, delta)
# Return the final list
return(list(ox = data.frame(lambda = ox_lambda, value = ox_value), red = data.frame(lambda = red_lambda, value = red_value),
delta = delta, Rmin = Rmin, Rmax = Rmax, R = R, OxD = OxD_values, E = E_values))
}
# Import GFP1/2 data
gfp1_dat <- read.csv("rogfp1.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
gfp2_dat <- read.csv("rogfp2.csv", header = FALSE, stringsAsFactors=FALSE,
fileEncoding="UTF-8-BOM")
# Set known midpoint potentials
gfp1_e0 <-  -288
gfp2_e0 <- -272
# Get other properties
gfp1_prop <- initSensor(gfp1_dat, c(390, 410), c(470, 480), gfp1_e0)
gfp2_prop <- initSensor(gfp2_dat, c(390, 410), c(490, 500), gfp2_e0)
par(pty = 's', mfrow = c(1,2), mai = c(0.2, 0.8, 0.4, 0.8))
plot(gfp1_prop$ox$value ~ gfp1_prop$ox$lambda, type = 'l', col = coolwarm(2)[1], main = "Emission spectrum of GFP1", xlab = expression(lambda), ylab = "Emission (relative)", bty = 'L')
points(gfp1_prop$red$value ~ gfp1_prop$red$value, type = 'l', col = coolwarm(2)[2])
legend("topright", xpd=TRUE, c("Oxidized", "Reduced"), pch = "-", lwd = 4, col = c(coolwarm(2)), cex = 1)
plot(gfp2_prop$ox$value ~ gfp2_prop$ox$lambda, type = 'l', col = coolwarm(2)[1], main = "Emission spectrum of GFP2", xlab = expression(lambda), ylab = "Emission (relative)", bty = 'L', ylim = c(0, 30))
points(gfp2_prop$red$value ~ gfp2_prop$red$lambda, type = 'l', col = coolwarm(2)[2])
legend("topleft", xpd=TRUE, c("Oxidized", "Reduced"), pch = "-", lwd = 4, col = c(coolwarm(2)), cex = 1)
gfp1_prop$ox
options(max.print = 15)
gfp1_prop$ox
subset(gfp1_prop$ox$lambda, (gfp1_prop$ox$value - gfp1_prop$red_value) < 1)
subset(gfp1_prop$ox$lambda, (gfp1_prop$ox$value - gfp1_prop$red$value) < 1)
subset(gfp1_prop$ox$lambda, (gfp1_prop$ox$value - gfp1_prop$red$value) < 0.1)
subset(gfp1_prop$ox$lambda, (gfp1_prop$ox$value - gfp1_prop$red$value) < 0.01)
subset(gfp1_prop$ox$lambda, (gfp1_prop$ox$value - gfp1_prop$red$value) < 0.001)
subset(gfp1_prop$ox$lambda, (gfp1_prop$ox$value - gfp1_prop$red$value) < 0.0001)
subset(gfp1_prop$ox$lambda, (gfp1_prop$ox$value - gfp1_prop$red$value) < 0.000000001)
subset(gfp1_prop$ox$lambda, (gfp1_prop$ox$value - gfp1_prop$red$value) < 0.000000001)
len(gfp1_prop$ox$value)
length(gfp1_prop$ox$value)
length(gfp1_pro$red$value)
length(gfp1_prop$red$value)
length(gfp1_prop$ox$value)
gfp1_prop$ox$value - gfp1_prop$red$value
min(5,4)
seq(1,2)
range <- 1:5
for (lambda in range) {print hi}
foreach (lambda in range) {print("hi")}
for (lambda in range) {print("hi")}
u
closest_value = Inf
closest_index = NaN
abs(-5)
# Turn two pairs of lambda-emission spectra into a 3-column dataframe
combine <- function(ox_lambda, ox_value, red_lambda, red_value) {
start <- max(ox_lambda[1], red_lambda[1])
end <- min(ox_lambda[length(ox_lambda)], red_lambda[length(red_lambda)])
range <- seq(start, end, by = 0.01)
ox_value_new <- c()
red_value_new <- c()
for (lambda in range) {
# Find the ox value closest to the lambda
closest_value = Inf
closest_index = NaN
for (old_lambda_index in 1:length(ox_lambda)) {
old_lambda = ox_lambda[old_lambda_index]
if (abs(old_lambda - lambda) < closest_value) {
closest_value = old_lambda
closest_index = old_lambda_index
}
}
ox_value_new <- c(ox_value_new, ox_value[closest_index])
# Find the red value closest to the lambda
closest_value = Inf
closest_index = NaN
for (old_lambda_index in 1:length(red_lambda)) {
old_lambda = red_lambda[old_lambda_index]
if (abs(old_lambda - lambda) < closest_value) {
closest_value = old_lambda
closest_index = old_lambda_index
}
}
ox_value_new <- c(ox_value_new, ox_value[closest_index])
}
return(data.frame(lambda = range, ox = ox_value_new, red = red_value_new))
}
combine(gfp1_prop$ox$lambda, gfp1_prop$ox$value, gfp1_prop$red$lambda, gfp1_prop$red$value)
# Turn two pairs of lambda-emission spectra into a 3-column dataframe
combine <- function(ox_lambda, ox_value, red_lambda, red_value) {
start <- max(ox_lambda[1], red_lambda[1])
end <- min(ox_lambda[length(ox_lambda)], red_lambda[length(red_lambda)])
range <- seq(start, end, by = 0.1)
ox_value_new <- c()
red_value_new <- c()
for (lambda in range) {
# Find the ox value closest to the lambda
closest_value = Inf
closest_index = NaN
for (old_lambda_index in 1:length(ox_lambda)) {
old_lambda = ox_lambda[old_lambda_index]
if (abs(old_lambda - lambda) < closest_value) {
closest_value = old_lambda
closest_index = old_lambda_index
}
}
ox_value_new <- c(ox_value_new, ox_value[closest_index])
# Find the red value closest to the lambda
closest_value = Inf
closest_index = NaN
for (old_lambda_index in 1:length(red_lambda)) {
old_lambda = red_lambda[old_lambda_index]
if (abs(old_lambda - lambda) < closest_value) {
closest_value = old_lambda
closest_index = old_lambda_index
}
}
red_value_new <- c(red_value_new, red_value[closest_index])
}
return(data.frame(lambda = range, ox = ox_value_new, red = red_value_new))
}
combine(gfp1_prop$ox$lambda, gfp1_prop$ox$value, gfp1_prop$red$lambda, gfp1_prop$red$value)
data.frame(combine(gfp1_prop$ox$lambda, gfp1_prop$ox$value, gfp1_prop$red$lambda, gfp1_prop$red$value), test = c(1,2,3)
)
data.frame(combine(gfp1_prop$ox$lambda, gfp1_prop$ox$value, gfp1_prop$red$lambda, gfp1_prop$red$value), test = 1:1520)
test <- combine(gfp1_prop$ox$lambda, gfp1_prop$ox$value, gfp1_prop$red$lambda, gfp1_prop$red$value)
plot(test$ox ~ test$lambda)
summary(test)
# Turn two pairs of lambda-emission spectra into a 3-column dataframe
combine <- function(ox_lambda, ox_value, red_lambda, red_value) {
start <- max(ox_lambda[1], red_lambda[1])
end <- min(ox_lambda[length(ox_lambda)], red_lambda[length(red_lambda)])
range <- seq(start, end, by = 0.1)
ox_value_new <- c()
red_value_new <- c()
for (lambda in range) {
# Find the ox value closest to the lambda
closest_value = Inf
closest_index = NaN
for (old_lambda_index in 1:length(ox_lambda)) {
old_lambda_diff = abs(ox_lambda[old_lambda_index] - lambda)
if (old_lambda_diff < closest_value) {
closest_value = old_lambda_diff
closest_index = old_lambda_index
}
}
ox_value_new <- c(ox_value_new, ox_value[closest_index])
# Find the red value closest to the lambda
closest_value = Inf
closest_index = NaN
for (old_lambda_index in 1:length(red_lambda)) {
old_lambda_diff = abs(red_lambda[old_lambda_index] - lambda)
if (old_lambda_diff < closest_value) {
closest_value = old_lambda_diff
closest_index = old_lambda_index
}
}
red_value_new <- c(red_value_new, red_value[closest_index])
}
return(data.frame(lambda = range, ox = ox_value_new, red = red_value_new))
}
test <- combine(gfp1_prop$ox$lambda, gfp1_prop$ox$value, gfp1_prop$red$lambda, gfp1_prop$red$value)
options(max.print = 50)
test
plot(test$ox ~ test$lambda)
plot(test$ox ~ test$lambda, type = 'l')
plot(gfp1_prop$ox$value ~ gfp1_prop$ox$lambda)
plot(test$ox ~ test$lambda, type = 'l')
plot(gfp1_prop$ox$value ~ gfp1_prop$ox$lambda, type = 'l')
# Write a function that, given a sensor and two sets of lambda bands, returns a list of properties
# Sensor data format:
initSensor <- function(sensor_data, lambda_1, lambda_2, e0) {
# Clean data
ox_lambda <- na.omit(sensor_data[[1]])
ox_value <- na.omit(sensor_data[[2]])
red_lambda <- na.omit(sensor_data[[3]])
red_value <- na.omit(sensor_data[[4]])
# Set delta
delta <- mean(ox_value[ox_lambda >= lambda_2[1] & ox_lambda <= lambda_2[2]]) /
mean(red_value[red_lambda >= lambda_2[1] & red_lambda <= lambda_2[2]])
# Set Rmin and Rmax
Rmin <- mean(red_value[red_lambda >= lambda_1[1] & red_lambda <= lambda_1[2]]) /
mean(red_value[red_lambda >= lambda_2[1] & red_lambda <= lambda_2[2]])
Rmax <- mean(ox_value[ox_lambda >= lambda_1[1] & ox_lambda <= lambda_1[2]]) /
mean(ox_value[ox_lambda >= lambda_2[1] & ox_lambda <= lambda_2[2]])
# Generate some R, OxD, and E values
R <- seq(Rmin, Rmax, by = 0.001)
OxD_values <- OXD(R, Rmin, Rmax, delta)
E_values <- E(e0, R, Rmin, Rmax, delta)
# Return the final list
return(list(data = combine(ox_lambda, ox_value, red_lambda, red_value),
delta = delta, Rmin = Rmin, Rmax = Rmax, R = R, OxD = OxD_values, E = E_values))
}
# Import GFP1/2 data
gfp1_dat <- read.csv("rogfp1.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
gfp2_dat <- read.csv("rogfp2.csv", header = FALSE, stringsAsFactors=FALSE,
fileEncoding="UTF-8-BOM")
# Set known midpoint potentials
gfp1_e0 <-  -288
gfp2_e0 <- -272
# Get other properties
gfp1_prop <- initSensor(gfp1_dat, c(390, 410), c(470, 480), gfp1_e0)
gfp2_prop <- initSensor(gfp2_dat, c(390, 410), c(490, 500), gfp2_e0)
par(pty = 's', mfrow = c(1,2), mai = c(0.2, 0.8, 0.4, 0.8))
plot(gfp1_prop$data$ox/gfp1_prop$data$red ~ gfp1_prop$data$lambda, type = 'l', col = black, main = "Lambda profile of roGFP1", xlab = expression(lambda), ylab = "lambda", bty = 'L')
plot(gfp2_prop$data$ox/gfp2_prop$data$red ~ gfp2_prop$data$lambda, type = 'l', col = black, main = "Lambda profile of roGFP2", xlab = expression(lambda), ylab = "lambda", bty = 'L')
par(pty = 's', mfrow = c(1,2), mai = c(0.2, 0.8, 0.4, 0.8))
plot(gfp1_prop$data$ox/gfp1_prop$data$red ~ gfp1_prop$data$lambda, type = 'l', col = 'black', main = "Lambda profile of roGFP1", xlab = expression(lambda), ylab = "lambda", bty = 'L')
plot(gfp2_prop$data$ox/gfp2_prop$data$red ~ gfp2_prop$data$lambda, type = 'l', col = 'black', main = "Lambda profile of roGFP2", xlab = expression(lambda), ylab = "lambda", bty = 'L')
par(pty = 's', mfrow = c(1,2), mai = c(0.2, 0.8, 0.4, 0.8))
plot(gfp1_prop$data$ox/gfp1_prop$data$red ~ gfp1_prop$data$lambda, type = 'l', col = 'black', main = "Lambda profile of roGFP1", xlab = expression(lambda), ylab = "lambda", bty = 'L')
plot(gfp2_prop$data$ox/gfp2_prop$data$red ~ gfp2_prop$data$lambda, type = 'l', col = 'black', main = "Lambda profile of roGFP2", xlab = expression(lambda), ylab = "lambda", bty = 'L')
par(pty = 's', mfrow = c(1,2), mai = c(0.2, 0.8, 0.4, 0.8))
plot(gfp1_prop$data$ox/gfp1_prop$data$red ~ gfp1_prop$data$lambda, type = 'l', col = 'black', main = "Lambda profile of roGFP1", xlab = expression(lambda), ylab = expression(delta), bty = 'L')
plot(gfp2_prop$data$ox/gfp2_prop$data$red ~ gfp2_prop$data$lambda, type = 'l', col = 'black', main = "Lambda profile of roGFP2", xlab = expression(lambda), ylab = expression(delta), bty = 'L')
par(pty = 's', mfrow = c(1,2), mai = c(0.4, 0.8, 0.4, 0.8))
plot(gfp1_prop$data$ox/gfp1_prop$data$red ~ gfp1_prop$data$lambda, col = 'black', main = "Lambda profile of roGFP1", xlab = expression(lambda), ylab = expression(delta), bty = 'L')
plot(gfp2_prop$data$ox/gfp2_prop$data$red ~ gfp2_prop$data$lambda, type = 'l', col = 'black', main = "Lambda profile of roGFP2", xlab = expression(lambda), ylab = expression(delta), bty = 'L')
print(min(abs(gfp1_deltas - 1)))
gfp1_deltas <- gfp1_prop$data$ox/gfp1_prop$data$red
print(min(abs(gfp1_deltas - 1)))
print(which.min(abs(gfp1_deltas - 1)))
print(paste("Wavelength in GFP1 where delta ~= 1: ", gfp1_prop$data$lambda[which.min(abs(gfp1_deltas - 1))]))
print(paste("Wavelength in GFP2 where delta ~= 1: ", gfp2_prop$data$lambda[which.min(abs(gfp2_deltas - 1))]))
gfp1_deltas <- gfp1_prop$data$ox/gfp1_prop$data$red
