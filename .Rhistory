})
setGeneric("R", signature = "interval", function(object) {
function(interval) standardGeneric("R")
})
setGeneric("R", function(object) {
function(interval) standardGeneric("R")
})
setMethod("R", signature(object = "Sensor", interval = 0.01), function(object) {
return(seq(object@Rmin, object@Rmax, by = interval))
})
setMethod("R", signature(object = "Sensor", interval = 0.01), function(object, interval) {
return(seq(object@Rmin, object@Rmax, by = interval))
})
setMethod("R", signature(object = "Sensor"), function(object, interval) {
return(seq(object@Rmin, object@Rmax, by = interval))
})
setGeneric("R", function(object, interval) {
function(interval) standardGeneric("R")
})
setMethod("R", signature(object = "Sensor"), function(object, interval) {
return(seq(object@Rmin, object@Rmax, by = interval))
})
R(test)
setGeneric("R", function(object, interval) {
standardGeneric("R")
})
setMethod("R", signature(object = "Sensor"), function(object, interval) {
return(seq(object@Rmin, object@Rmax, by = interval))
})
R(test)
R(test, interval = 0.01)
R(test, interval = 0.001)
R(test, interval = 1)
setGeneric("R", function(object, interval) {
standardGeneric("R")
})
setMethod("R", signature(object = "Sensor"), function(object, interval = 0.01) {
return(seq(object@Rmin, object@Rmax, by = interval))
})
R(test)
typeof(test)
setGeneric("R", function(object, interval = 0.01) {
standardGeneric("R")
})
setMethod("R", signature(object = "Sensor"), function(object, interval = 0.01) {
return(seq(object@Rmin, object@Rmax, by = interval))
})
typeof(test)
R(test)
standardGeneric("R")
setGeneric("R", function(object, interval = 0.01) {
standardGeneric("R")
})
setGeneric("R", function(object, interval = 0.01) {
standardGeneric("R")
})
setMethod("R", signature(object = "Sensor"), function(object) {
return(seq(object@Rmin, object@Rmax, by = interval))
})
R(test)
setGeneric("R", function(object, interval = 0.01) {
standardGeneric("R")
})
setMethod("R", signature(object = "Sensor"), function(object) {
return(seq(object@Rmin, object@Rmax, by = interval))
})
R(test)
setGeneric("R", function(object, interval = 0.01) {
standardGeneric("R")
})
setMethod("R", signature(object = "Sensor"), function(object, interval) {
return(seq(object@Rmin, object@Rmax, by = interval))
})
R(test)
R(test, interval = 1)
return (
(R - Rmin)/((R - Rmin) + (delta*(Rmax - R)))
)
# Define the fraction oxidized
OXD <- function(R, Rmin, Rmax, delta) {
return (
(R - Rmin)/((R - Rmin) + (delta*(Rmax - R)))
)
}
setGeneric(OXD)
setGeneric("R",OXD)
setGeneric("OXD",OXD)
setMethod("OxD", signature(object = "Sensor"))
setMethod("OXD", signature(object = "Sensor"))
setMethod("OXD", signature(object = "Sensor"), function(object) {
return(OXD(R(object), object@Rmin, object@Rmax, object@delta))
}
)
setMethod("OXD", signature(object = "Sensor"), function(object) {
return( object@Rmin, object@Rmax, object@delta))
})
setMethod("OXD", signature(object = "Sensor"), function(object) {
return(OXD(object@Rmin, object@Rmax, object@delta))
})
test
typeof(test)
R <- function(Sensor, interval) {
return(seq(Sensor@Rmin, Sensor@Rmax, by = interval))
}
R(test, interval)
R(test, 1)
R(test, 0.5)
new("redoxSensor", test, "200")
new("redoxSensor", test, 200)
new("redoxSensor", test, e0 = 200)
setClass("sensorSpectra",
slots =
list(lambda = "numeric",
values_state1 = "numeric",
values_state2 = "numeric"
))
typeof(c(1,2,3))
typeof(c(1,2,3.))
is.numeric(c(1,2,3))
is.double(c(1,2,3))
is.double(c(1,2,3.3))
lambdas <- c(1,2,3,4,5,6,7,8,9,10)
(lambdas >= 5 & lambdas <= 10)
# Sensor constructors
# lambda_1 and lambda_2 are arrays of length two describing the range of values to measure
newSensorFromSpectra <- function(sensorSpectra, lambda_1, lambda_2) {
values_maximum = sensorSpectra@values_maximum
values_minimum = sensorSpectra@values_minimum
lambdas = sensorSpectra@lambdas
relevant_lambda_1 <- (lambdas >= lambda_1[1] & lambdas <= lambda_1[2])
relevant_lambda_2 <- (lambdas >= lambda_2[1] & lambdas <= lambda_2[2])
delta <- mean(values_maximum[relevant_lambda_2]) /
mean(values_minimum[relevant_lambda_2])
Rmin <- mean(values_minimum[relevant_lambda_1]) /
mean(values_minimum[relevant_lambda_2])
Rmax <- mean(values_maximum[relevant_lambda_1]) /
mean(values_maximum[relevant_lambda_2])
}
# values_minimum represents state corresponding to Rmin
# values_maximum represents state corresponding to Rmax
setClass("sensorSpectra",
slots =
list(lambdas = "numeric",
values_minimum = "numeric",
values_maximum = "numeric"
))
# Sensor constructors
# lambda_1 and lambda_2 are arrays of length two describing the range of values to measure
newSensorFromSpectra <- function(sensorSpectra, lambda_1, lambda_2) {
values_maximum = sensorSpectra@values_maximum
values_minimum = sensorSpectra@values_minimum
lambdas = sensorSpectra@lambdas
# Make boolean vectors describing which of the lambdas are relevant
relevant_lambda_1 <- (lambdas >= lambda_1[1] & lambdas <= lambda_1[2])
relevant_lambda_2 <- (lambdas >= lambda_2[1] & lambdas <= lambda_2[2])
# Set the parameters required for a sensor
delta <- mean(values_maximum[relevant_lambda_2]) /
mean(values_minimum[relevant_lambda_2])
Rmin <- mean(values_minimum[relevant_lambda_1]) /
mean(values_minimum[relevant_lambda_2])
Rmax <- mean(values_maximum[relevant_lambda_1]) /
mean(values_maximum[relevant_lambda_2])
# Make a new sensor
return(new("Sensor", Rmax = Rmax, Rmin = Rmin, delta = delta))
}
# Rescale y to the same size as the new x values
rescaleToRange <- function(new_xs, old_xs, y) {
# Initalize rescaled y values
new_y <- c()
# Loop through each new x value
for (new_x in new_xs) {
# Initalize the closest old_x value found
closest_x_difference <- Inf
# Initalize the index corresponding to the closest old_x value found
closest_x_index <- NaN
# Loop through each index of old x
for (old_x_index in 1:length(old_xs)) {
new_old_diff <- abs(old_xs[old_xs_index] - new_x)
if (new_old_diff < closest_x_index) {
closest_x_difference <- new_old_diff
closest_x_index <- old_xs_index
}
}
# Accumulate new y values corresponding to the closest old_x found
new_y <- c(new_y, y[closest_x_index])
}
return(new_y)
}
# values_minimum represents state corresponding to Rmin
# values_maximum represents state corresponding to Rmax
# Turn two pairs of lambda-emission spectra into a 3-column dataframe
spectraMatrixFromValues <- function(lambdas_minimum, values_minimum, lambdas_maximum, values_maximum) {
# Set beginning and ending lambda values
# Warning: will trim lambdas not in the range of shared values
start <- max(min(lambdas_minimum),
min(lambdas_maximum))
end <- min(max(lambdas_minimum),
max(lambdas_maximum))
range <- seq(start, end, by = 0.1)
new_values_minimum <- rescaleToRange(new_xs = range, old_xs = lambdas_minimum, y = values_minimum)
new_values_maximum <- rescaleToRange(new_xs = range, old_xs = lambdas_maximum, y = values_maximum)
return(new("sensorSpectra",
lambdas = range, values_minimum = new_values_minimum, values_maximum = new_values_maximum))
}
spectraMatrixFromValues(lambdas_minimum = c(1,2,3,4,5), values_minimum = c(10, 20, 30, 40, 50), lambdas_maximum = c(2,3,4,5,6), values_maximum = c(50, 40, 30, 20, 10))
# Rescale y to the same size as the new x values
rescaleToRange <- function(new_xs, old_xs, y) {
# Initalize rescaled y values
new_y <- c()
# Loop through each new x value
for (new_x in new_xs) {
# Initalize the closest old_x value found
closest_x_difference <- Inf
# Initalize the index corresponding to the closest old_x value found
closest_x_index <- NaN
# Loop through each index of old x
for (old_x_index in 1:length(old_xs)) {
new_old_diff <- abs(old_xs[old_x_index] - new_x)
if (new_old_diff < closest_x_index) {
closest_x_difference <- new_old_diff
closest_x_index <- old_xs_index
}
}
# Accumulate new y values corresponding to the closest old_x found
new_y <- c(new_y, y[closest_x_index])
}
return(new_y)
}
spectraMatrixFromValues(lambdas_minimum = c(1,2,3,4,5), values_minimum = c(10, 20, 30, 40, 50), lambdas_maximum = c(2,3,4,5,6), values_maximum = c(50, 40, 30, 20, 10))
# Rescale y to the same size as the new x values
rescaleToRange <- function(new_xs, old_xs, y) {
# Initalize rescaled y values
new_y <- c()
# Loop through each new x value
for (new_x in new_xs) {
# Initalize the closest old_x value found
closest_x_difference <- Inf
# Initalize the index corresponding to the closest old_x value found
closest_x_index <- NaN
# Loop through each index of old x
for (old_x_index in 1:length(old_xs)) {
new_old_diff <- abs(old_xs[old_x_index] - new_x)
print(new_old_diff)
print(closest_x_index)
if (new_old_diff < closest_x_index) {
closest_x_difference <- new_old_diff
closest_x_index <- old_xs_index
}
}
# Accumulate new y values corresponding to the closest old_x found
new_y <- c(new_y, y[closest_x_index])
}
return(new_y)
}
spectraMatrixFromValues(lambdas_minimum = c(1,2,3,4,5), values_minimum = c(10, 20, 30, 40, 50), lambdas_maximum = c(2,3,4,5,6), values_maximum = c(50, 40, 30, 20, 10))
1 < Nan
1 < NaN
# Rescale y to the same size as the new x values
rescaleToRange <- function(new_xs, old_xs, y) {
# Initalize rescaled y values
new_y <- c()
# Loop through each new x value
for (new_x in new_xs) {
# Initalize the closest old_x value found
closest_x_difference <- Inf
# Initalize the index corresponding to the closest old_x value found
closest_x_index <- NaN
# Loop through each index of old x
for (old_x_index in 1:length(old_xs)) {
new_old_diff <- abs(old_xs[old_x_index] - new_x)
print(new_old_diff)
print(closest_x_index)
if (new_old_diff < closest_x_difference) {
closest_x_difference <- new_old_diff
closest_x_index <- old_xs_index
}
}
# Accumulate new y values corresponding to the closest old_x found
new_y <- c(new_y, y[closest_x_index])
}
return(new_y)
}
spectraMatrixFromValues(lambdas_minimum = c(1,2,3,4,5), values_minimum = c(10, 20, 30, 40, 50), lambdas_maximum = c(2,3,4,5,6), values_maximum = c(50, 40, 30, 20, 10))
# Rescale y to the same size as the new x values
rescaleToRange <- function(new_xs, old_xs, y) {
# Initalize rescaled y values
new_y <- c()
# Loop through each new x value
for (new_x in new_xs) {
# Initalize the closest old_x value found
closest_x_difference <- Inf
# Initalize the index corresponding to the closest old_x value found
closest_x_index <- NaN
# Loop through each index of old x
for (old_x_index in 1:length(old_xs)) {
new_old_diff <- abs(old_xs[old_x_index] - new_x)
print(new_old_diff)
print(closest_x_difference)
if (new_old_diff < closest_x_difference) {
closest_x_difference <- new_old_diff
closest_x_index <- old_x_index
}
}
# Accumulate new y values corresponding to the closest old_x found
new_y <- c(new_y, y[closest_x_index])
}
return(new_y)
}
spectraMatrixFromValues(lambdas_minimum = c(1,2,3,4,5), values_minimum = c(10, 20, 30, 40, 50), lambdas_maximum = c(2,3,4,5,6), values_maximum = c(50, 40, 30, 20, 10))
# Rescale y to the same size as the new x values
rescaleToRange <- function(new_xs, old_xs, y) {
# Initalize rescaled y values
new_y <- c()
# Loop through each new x value
for (new_x in new_xs) {
# Initalize the closest old_x value found
closest_x_difference <- Inf
# Initalize the index corresponding to the closest old_x value found
closest_x_index <- NaN
# Loop through each index of old x
for (old_x_index in 1:length(old_xs)) {
new_old_diff <- abs(old_xs[old_x_index] - new_x)
if (new_old_diff < closest_x_difference) {
closest_x_difference <- new_old_diff
closest_x_index <- old_x_index
}
}
# Accumulate new y values corresponding to the closest old_x found
new_y <- c(new_y, y[closest_x_index])
}
return(new_y)
}
roGFP1 <- new("redoxSensor", Rmin = 4.3, Rmax = 30.6, delta = 0.2, e0 = -281)
roGFP1_R12_empirical <- new("redoxSensor", Rmin = 0.667, Rmax = 5.207, delta = 0.171)
roGFP1_iE <- new("redoxSensor", Rmin = 0.856, Rmax = 3.875, delta = 0.5, e0 = -236)
roGFP2 <- new("redoxSensor", Rmin = 0.09, Rmax = 1.7, delta = 0.3, e0 = -272)
grx1_roGFP2 <-  new("redoxSensor", Rmin = 0.3, Rmax = 2.0, delta = 0.5, e0 = -272)
roGFP2_iL <- new("redoxSensor", Rmin = 0.19, Rmax = 0.45, delta = 0.65, e0 = -229)
roGFP2
test <- new("Sensor", Rmin = 1, Rmax = 2, delta = 0.5)
test2 <- new("Sensor", Rmin = 10, Rmax = 20, delta = 5)
c(test, test2)
testList <0 c(test, test2)
testList <- c(test, test2)
testList[1]
testList[2]
testList[2]@Rmin
testList[[2]]@Rmin
testList[[1]]@Rmin
for (sensor in testList) {print(sensor@Rmin)}
data <- data.frame(x = c(1,2,3,4,5), y = c(10, 20, 30 , 40 ,50))
data
plot <- ggplot(data, aes(x, y))
library(ggplot2)
plot <- ggplot(data, aes(x, y))
plot
plot + geom_point()
plot + geom_point(size = 50)
plot + geom_point(size = 5)
plot2 <- plot + geom_point(size = 5)
plot2 + geom_point(size = 1)
plot2 + geom_point(size = 10)
plot2 + geom_point(size = 5)
plot2 + geom_point(size = 4)
ggplot_build(plot2)
plot2$layers
plot2$layers[[1]]
plot2$layers[[2]]
lay <- plot2$layers
lay[1]
lay[2]
plot2
remove_geom(plot2, geom_point)
library(ggedit)
install.packages('ggedit')
library(ggedit)
plot2
remoe_geom(plot2, geom_point)
remove_geom(plot2, geom_point)
remove_geom(plot2, "geom_point")
plot2$layers
remove_geom(plot2, "point")
# Define coolwarm color gradient
coolwarm <- colorRampPalette(c(
rgb( 60, 81,198, maxColorValue = 255),
rgb( 61, 86,203, maxColorValue = 255),
rgb( 63, 91,207, maxColorValue = 255),
rgb( 65, 96,212, maxColorValue = 255),
rgb( 67,101,216, maxColorValue = 255),
rgb( 69,106,220, maxColorValue = 255),
rgb( 71,111,224, maxColorValue = 255),
rgb( 74,116,227, maxColorValue = 255),
rgb( 76,121,231, maxColorValue = 255),
rgb( 79,127,233, maxColorValue = 255),
rgb( 83,132,236, maxColorValue = 255),
rgb( 86,137,238, maxColorValue = 255),
rgb( 90,143,240, maxColorValue = 255),
rgb( 94,148,242, maxColorValue = 255),
rgb( 99,153,243, maxColorValue = 255),
rgb(103,159,244, maxColorValue = 255),
rgb(109,164,244, maxColorValue = 255),
rgb(114,169,245, maxColorValue = 255),
rgb(120,174,245, maxColorValue = 255),
rgb(126,179,245, maxColorValue = 255),
rgb(132,184,244, maxColorValue = 255),
rgb(139,188,243, maxColorValue = 255),
rgb(146,193,242, maxColorValue = 255),
rgb(153,197,241, maxColorValue = 255),
rgb(161,201,239, maxColorValue = 255),
rgb(169,205,238, maxColorValue = 255),
rgb(177,209,236, maxColorValue = 255),
rgb(186,212,233, maxColorValue = 255),
rgb(195,215,231, maxColorValue = 255),
rgb(204,218,229, maxColorValue = 255),
rgb(214,221,226, maxColorValue = 255),
rgb(223,223,223, maxColorValue = 255),
rgb(235,218,215, maxColorValue = 255),
rgb(245,213,207, maxColorValue = 255),
rgb(255,206,198, maxColorValue = 255),
rgb(255,192,184, maxColorValue = 255),
rgb(255,180,170, maxColorValue = 255),
rgb(255,168,159, maxColorValue = 255),
rgb(255,157,148, maxColorValue = 255),
rgb(255,147,139, maxColorValue = 255),
rgb(255,138,130, maxColorValue = 255),
rgb(255,129,122, maxColorValue = 255),
rgb(255,121,115, maxColorValue = 255),
rgb(255,113,109, maxColorValue = 255),
rgb(255,105,103, maxColorValue = 255),
rgb(255, 98, 98, maxColorValue = 255),
rgb(255, 91, 93, maxColorValue = 255),
rgb(255, 85, 89, maxColorValue = 255),
rgb(255, 78, 85, maxColorValue = 255),
rgb(255, 72, 81, maxColorValue = 255),
rgb(255, 67, 78, maxColorValue = 255),
rgb(255, 61, 75, maxColorValue = 255),
rgb(255, 56, 72, maxColorValue = 255),
rgb(255, 50, 70, maxColorValue = 255),
rgb(255, 45, 67, maxColorValue = 255),
rgb(255, 41, 65, maxColorValue = 255),
rgb(252, 35, 62, maxColorValue = 255),
rgb(242, 30, 58, maxColorValue = 255),
rgb(233, 24, 55, maxColorValue = 255),
rgb(223, 20, 51, maxColorValue = 255),
rgb(212, 15, 48, maxColorValue = 255),
rgb(202, 11, 44, maxColorValue = 255),
rgb(191,  7, 41, maxColorValue = 255),
rgb(180,  4, 38, maxColorValue = 255)))
colors4 <- c(
rgb(151, 99, 172, maxColorValue = 255),
rgb(214, 154, 191, maxColorValue = 255),
rgb(249, 188, 112, maxColorValue = 255),
rgb(224, 120, 34, maxColorValue = 255))
# Define plotting parameters
cex.lab <- 1.5
cex.axis <- 1.5
coolwarm(2)
library(sensorOverlord)
# Import GFP1/2 data
gfp1r12_dat <- read.csv("rogfp1r12.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
setwd("C:/Users/Julian/Desktop/2018 Ubuntu Shared/GitShared/Ratiometric_Microscopy/Final Report/Sensor Comparison")
# Import GFP1/2 data
gfp1r12_dat <- read.csv("rogfp1r12.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
head(gfp1r12_dat)
help(package="sensorOverlord")
rogfp1r12_matrix <- spectraMatrixFromValues(gfp1r12_dat$V3, gfp1r12_dat$V4, gfp1r12_dat$V1, gfp1r12_dat$V2)
rogfp1r12_matrix
rogfp1r12_sensor <- newSensorFromSpectra(rogfp1r12_matrix, c(390, 420), c(460, 480))
rogfp1r12_sensor
rogfp1r12_sensor@Rmax / rogfp1r12_sensor@Rmin
rogfp1r12_sensor <- newSensorFromSpectra(rogfp1r12_matrix, c(400, 420), c(465, 475))
rogfp1r12_sensor
plotSpectra(rogfp1r12_matrix)
library(sensorOverlord)
plotSpectra(rogfp1r12_matrix)
# Import GFP1/2 data
gfp1r12_dat <- read.csv("rogfp1r12.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
rogfp1r12_matrix <- spectraMatrixFromValues(gfp1r12_dat$V3, gfp1r12_dat$V4, gfp1r12_dat$V1, gfp1r12_dat$V2)
plotSpectra(rogfp1r12_matrix)
.rs.restartR()
plotSpectra(rogfp1r12_matrix)
library(sensorOverlord)
plotSpectra(rogfp1r12_matrix)
library(sensorOverlord)
plotSpectra(rogfp1r12_matrix)
rogfp1r12_matrix
rogfp1r12_matrix
plotSpectra(rogfp1r12_matrix)
library(sensorOverlord)
help(package="sensorOverlord")
# Import GFP1/2 data
gfp1r12_dat <- read.csv("rogfp1r12.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
setwd("C:/Users/Julian/Desktop/2018 Ubuntu Shared/GitShared/Ratiometric_Microscopy/Final Report/Sensor Comparison")
# Import GFP1/2 data
gfp1r12_dat <- read.csv("rogfp1r12.csv", header = FALSE, stringsAsFactors = FALSE,
fileEncoding="UTF-8-BOM")
rogfp1r12_matrix <- spectraMatrixFromValues(gfp1r12_dat$V3, gfp1r12_dat$V4, gfp1r12_dat$V1, gfp1r12_dat$V2)
rogfp1r12_matrix <- spectraMatrixFromValues(gfp1r12_dat$V3, gfp1r12_dat$V4, gfp1r12_dat$V1, gfp1r12_dat$V2)
rogfp1r12_matrix <- spectraMatrixFromValues(gfp1r12_dat$V3, gfp1r12_dat$V4, gfp1r12_dat$V1, gfp1r12_dat$V2)
rogfp1r12_matrix <- spectraMatrixFromValues(gfp1r12_dat$V3, gfp1r12_dat$V4, gfp1r12_dat$V1, gfp1r12_dat$V2)
library(sensorOverlord)
rogfp1r12_matrix <- spectraMatrixFromValues(gfp1r12_dat$V3, gfp1r12_dat$V4, gfp1r12_dat$V1, gfp1r12_dat$V2)
library(sensorOverlord)
rogfp1r12_matrix <- spectraMatrixFromValues(gfp1r12_dat$V3, gfp1r12_dat$V4, gfp1r12_dat$V1, gfp1r12_dat$V2)
remove.packages("sensorOverlord", lib="~/R/win-library/3.5")
library(sensorOverlord)
rogfp1r12_matrix <- spectraMatrixFromValues(gfp1r12_dat$V3, gfp1r12_dat$V4, gfp1r12_dat$V1, gfp1r12_dat$V2)
SpectraMatrixFromValues
